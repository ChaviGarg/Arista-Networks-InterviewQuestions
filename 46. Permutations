class Solution {
    List<List<Integer>> result = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> list = new ArrayList<>();
        boolean visited[] = new boolean[nums.length];
        permuteHelper(nums, nums.length, list, visited);
        return result;
    }
    private void permuteHelper(int[] nums, int n, List<Integer> list, boolean visited[]){
        if(list.size() == n)
           result.add(new ArrayList<>(list));
        for(int i=0; i < n; i++){
            if(visited[i])
               continue;
            list.add(nums[i]);
            visited[i] = true;
            permuteHelper(nums, n, list, visited);
            visited[i] = false;
            list.remove(list.size()-1);
        }
    }
}


Given n as the length of nums,

Time complexity, what you should say in an interview: O(n⋅n!)

Finding permutations is a well-studied problem in combinatorics. Given a set of length n, the number of permutations is n! (n factorial). There are n options for the first number, n−1 for the second, and so on.

For each of the n! permutations, we need O(n) work to copy curr into the answer. This gives us O(n⋅n!) work.

Space complexity: O(n)

We don't count the answer as part of the space complexity. The extra space we use here is for curr and the recursion call stack. The depth of the call stack is equal to the length of curr, which is limited to n.

Fortunately, this analysis was simpler than the time complexity one.
